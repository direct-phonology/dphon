<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dphon.console API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dphon.console</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Tuple, List

from rich.console import Console
from rich.highlighter import RegexHighlighter
from rich.theme import Theme

from .match import Match
from .g2p import GraphemesToPhonemes


# Default color scheme for highlighting matches
DEFAULT_THEME = Theme({
    &#34;context&#34;: &#34;dim&#34;,
    &#34;variant&#34;: &#34;blue&#34;,
    &#34;insertion&#34;: &#34;green&#34;,
    &#34;mismatch&#34;: &#34;red&#34;
})

# Consoles for rendering output
console = Console(theme=DEFAULT_THEME, soft_wrap=True)
err_console = Console(theme=DEFAULT_THEME, stderr=True)


class MatchHighlighter(RegexHighlighter):
    &#34;&#34;&#34;Highlighter that adds Rich markup to matches for console rendering.&#34;&#34;&#34;

    context: int
    gap_char: str
    g2p: GraphemesToPhonemes

    def __init__(self, g2p: GraphemesToPhonemes, context: int = 0, gap_char: str = &#34;-&#34;) -&gt; None:
        &#34;&#34;&#34;Create a new highlighter with optional context for each match.&#34;&#34;&#34;
        # can&#39;t have negative context
        if context &lt; 0:
            raise ValueError(
                f&#34;{self.__class__} context must be greater than 0&#34;)

        # store parameters
        self.context = context
        self.gap_char = gap_char
        self.g2p = g2p
        super().__init__()

    def format_match(self, match: Match) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Return match sequences as Rich format strings, with optional context.

        Adds markup for highlighting insertions, mismatches, etc. If context is 
        set, also adds highlighted context to either end of the match.
        &#34;&#34;&#34;

        su, sv = self._mark(match)
        if self.context &gt; 0:
            cul, cur, cvl, cvr = self._add_context(match)
            su = cul + su + cur
            sv = cvl + sv + cvr
        return su, sv

    def _mark(self, match: Match) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Mark up the match for colorization with a theme.

        - Adds markup for insertions (tokens in one sequence but not another).
        - Adds markup for mismatches (differing tokens in the same position).
        - Adds markup for graphic variants (mismatches with same phonemes).
        &#34;&#34;&#34;

        # if no alignment, just convert to strings because we can&#39;t highlight
        if not match.au or not match.av:
            return match.utxt.text, match.vtxt.text

        # o(N) implementation: step through each sequence adding markup
        # TODO convert to a DFA so there&#39;s less markup repetition
        su: List[str] = []
        sv: List[str] = []
        u_ptr = 0
        v_ptr = 0
        for i in range(len(match)):

            # gap in u: insertion in v (if not punctuation)
            if match.au[i] == self.gap_char and match.av[i].isalnum():
                su.append(match.au[i])
                sv.append(f&#34;[insertion]{match.av[i]}[/insertion]&#34;)
                v_ptr += 1
                continue

            # gap in v: insertion in u (if not punctuation)
            if match.av[i] == self.gap_char  and match.au[i].isalnum():
                su.append(f&#34;[insertion]{match.au[i]}[/insertion]&#34;)
                sv.append(match.av[i])
                u_ptr += 1
                continue

            # variants (both u and v)
            if self.g2p.are_graphic_variants(match.utxt[u_ptr], match.vtxt[v_ptr]):
                su.append(f&#34;[variant]{match.au[i]}[/variant]&#34;)
                sv.append(f&#34;[variant]{match.av[i]}[/variant]&#34;)
                u_ptr += 1
                v_ptr += 1
                continue

            # mismatch (both u and v) - only highlight if alphanumeric
            if match.au[i] != match.av[i]:
                if match.au[i].isalnum() and match.av[i].isalnum():
                    su.append(f&#34;[mismatch]{match.au[i]}[/mismatch]&#34;)
                    sv.append(f&#34;[mismatch]{match.av[i]}[/mismatch]&#34;)
                    u_ptr += 1
                    v_ptr += 1
                    continue

            # equality; nothing to highlight
            su.append(match.au[i])
            sv.append(match.av[i])
            u_ptr += 1
            v_ptr += 1

        return &#34;&#34;.join(su), &#34;&#34;.join(sv)

    def _add_context(self, match: Match) -&gt; Tuple[str, str, str, str]:
        &#34;&#34;&#34;Add context to either side of the match sequences.

        Context coloration can be changed by the default theme; a dim appearance
        is used in terminals.
        &#34;&#34;&#34;

        utxt, vtxt = match.utxt, match.vtxt
        u, v = utxt.doc, vtxt.doc
        cul = f&#34;[context]{u[utxt.start-self.context:utxt.start]}[/context]&#34;
        cur = f&#34;[context]{u[utxt.end:utxt.end+self.context]}[/context]&#34;
        cvl = f&#34;[context]{v[vtxt.start-self.context:vtxt.start]}[/context]&#34;
        cvr = f&#34;[context]{v[vtxt.end:vtxt.end+self.context]}[/context]&#34;
        return (cul, cur, cvl, cvr)

    def transcription(self, match: Match) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Get the phonemic transcription for the match for display.&#34;&#34;&#34;
        return (
            &#34;*&#34; + &#34; &#34;.join(match.utxt._.syllables),
            &#34;*&#34; + &#34; &#34;.join(match.vtxt._.syllables)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dphon.console.MatchHighlighter"><code class="flex name class">
<span>class <span class="ident">MatchHighlighter</span></span>
<span>(</span><span>g2p: <a title="dphon.g2p.GraphemesToPhonemes" href="g2p.html#dphon.g2p.GraphemesToPhonemes">GraphemesToPhonemes</a>, context: int = 0, gap_char: str = '-')</span>
</code></dt>
<dd>
<div class="desc"><p>Highlighter that adds Rich markup to matches for console rendering.</p>
<p>Create a new highlighter with optional context for each match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MatchHighlighter(RegexHighlighter):
    &#34;&#34;&#34;Highlighter that adds Rich markup to matches for console rendering.&#34;&#34;&#34;

    context: int
    gap_char: str
    g2p: GraphemesToPhonemes

    def __init__(self, g2p: GraphemesToPhonemes, context: int = 0, gap_char: str = &#34;-&#34;) -&gt; None:
        &#34;&#34;&#34;Create a new highlighter with optional context for each match.&#34;&#34;&#34;
        # can&#39;t have negative context
        if context &lt; 0:
            raise ValueError(
                f&#34;{self.__class__} context must be greater than 0&#34;)

        # store parameters
        self.context = context
        self.gap_char = gap_char
        self.g2p = g2p
        super().__init__()

    def format_match(self, match: Match) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Return match sequences as Rich format strings, with optional context.

        Adds markup for highlighting insertions, mismatches, etc. If context is 
        set, also adds highlighted context to either end of the match.
        &#34;&#34;&#34;

        su, sv = self._mark(match)
        if self.context &gt; 0:
            cul, cur, cvl, cvr = self._add_context(match)
            su = cul + su + cur
            sv = cvl + sv + cvr
        return su, sv

    def _mark(self, match: Match) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Mark up the match for colorization with a theme.

        - Adds markup for insertions (tokens in one sequence but not another).
        - Adds markup for mismatches (differing tokens in the same position).
        - Adds markup for graphic variants (mismatches with same phonemes).
        &#34;&#34;&#34;

        # if no alignment, just convert to strings because we can&#39;t highlight
        if not match.au or not match.av:
            return match.utxt.text, match.vtxt.text

        # o(N) implementation: step through each sequence adding markup
        # TODO convert to a DFA so there&#39;s less markup repetition
        su: List[str] = []
        sv: List[str] = []
        u_ptr = 0
        v_ptr = 0
        for i in range(len(match)):

            # gap in u: insertion in v (if not punctuation)
            if match.au[i] == self.gap_char and match.av[i].isalnum():
                su.append(match.au[i])
                sv.append(f&#34;[insertion]{match.av[i]}[/insertion]&#34;)
                v_ptr += 1
                continue

            # gap in v: insertion in u (if not punctuation)
            if match.av[i] == self.gap_char  and match.au[i].isalnum():
                su.append(f&#34;[insertion]{match.au[i]}[/insertion]&#34;)
                sv.append(match.av[i])
                u_ptr += 1
                continue

            # variants (both u and v)
            if self.g2p.are_graphic_variants(match.utxt[u_ptr], match.vtxt[v_ptr]):
                su.append(f&#34;[variant]{match.au[i]}[/variant]&#34;)
                sv.append(f&#34;[variant]{match.av[i]}[/variant]&#34;)
                u_ptr += 1
                v_ptr += 1
                continue

            # mismatch (both u and v) - only highlight if alphanumeric
            if match.au[i] != match.av[i]:
                if match.au[i].isalnum() and match.av[i].isalnum():
                    su.append(f&#34;[mismatch]{match.au[i]}[/mismatch]&#34;)
                    sv.append(f&#34;[mismatch]{match.av[i]}[/mismatch]&#34;)
                    u_ptr += 1
                    v_ptr += 1
                    continue

            # equality; nothing to highlight
            su.append(match.au[i])
            sv.append(match.av[i])
            u_ptr += 1
            v_ptr += 1

        return &#34;&#34;.join(su), &#34;&#34;.join(sv)

    def _add_context(self, match: Match) -&gt; Tuple[str, str, str, str]:
        &#34;&#34;&#34;Add context to either side of the match sequences.

        Context coloration can be changed by the default theme; a dim appearance
        is used in terminals.
        &#34;&#34;&#34;

        utxt, vtxt = match.utxt, match.vtxt
        u, v = utxt.doc, vtxt.doc
        cul = f&#34;[context]{u[utxt.start-self.context:utxt.start]}[/context]&#34;
        cur = f&#34;[context]{u[utxt.end:utxt.end+self.context]}[/context]&#34;
        cvl = f&#34;[context]{v[vtxt.start-self.context:vtxt.start]}[/context]&#34;
        cvr = f&#34;[context]{v[vtxt.end:vtxt.end+self.context]}[/context]&#34;
        return (cul, cur, cvl, cvr)

    def transcription(self, match: Match) -&gt; Tuple[str, str]:
        &#34;&#34;&#34;Get the phonemic transcription for the match for display.&#34;&#34;&#34;
        return (
            &#34;*&#34; + &#34; &#34;.join(match.utxt._.syllables),
            &#34;*&#34; + &#34; &#34;.join(match.vtxt._.syllables)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>rich.highlighter.RegexHighlighter</li>
<li>rich.highlighter.Highlighter</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dphon.console.MatchHighlighter.context"><code class="name">var <span class="ident">context</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dphon.console.MatchHighlighter.g2p"><code class="name">var <span class="ident">g2p</span> : <a title="dphon.g2p.GraphemesToPhonemes" href="g2p.html#dphon.g2p.GraphemesToPhonemes">GraphemesToPhonemes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dphon.console.MatchHighlighter.gap_char"><code class="name">var <span class="ident">gap_char</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dphon.console.MatchHighlighter.format_match"><code class="name flex">
<span>def <span class="ident">format_match</span></span>(<span>self, match: <a title="dphon.match.Match" href="match.html#dphon.match.Match">Match</a>) ‑> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return match sequences as Rich format strings, with optional context.</p>
<p>Adds markup for highlighting insertions, mismatches, etc. If context is
set, also adds highlighted context to either end of the match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_match(self, match: Match) -&gt; Tuple[str, str]:
    &#34;&#34;&#34;Return match sequences as Rich format strings, with optional context.

    Adds markup for highlighting insertions, mismatches, etc. If context is 
    set, also adds highlighted context to either end of the match.
    &#34;&#34;&#34;

    su, sv = self._mark(match)
    if self.context &gt; 0:
        cul, cur, cvl, cvr = self._add_context(match)
        su = cul + su + cur
        sv = cvl + sv + cvr
    return su, sv</code></pre>
</details>
</dd>
<dt id="dphon.console.MatchHighlighter.transcription"><code class="name flex">
<span>def <span class="ident">transcription</span></span>(<span>self, match: <a title="dphon.match.Match" href="match.html#dphon.match.Match">Match</a>) ‑> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the phonemic transcription for the match for display.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transcription(self, match: Match) -&gt; Tuple[str, str]:
    &#34;&#34;&#34;Get the phonemic transcription for the match for display.&#34;&#34;&#34;
    return (
        &#34;*&#34; + &#34; &#34;.join(match.utxt._.syllables),
        &#34;*&#34; + &#34; &#34;.join(match.vtxt._.syllables)
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dphon" href="index.html">dphon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dphon.console.MatchHighlighter" href="#dphon.console.MatchHighlighter">MatchHighlighter</a></code></h4>
<ul class="">
<li><code><a title="dphon.console.MatchHighlighter.context" href="#dphon.console.MatchHighlighter.context">context</a></code></li>
<li><code><a title="dphon.console.MatchHighlighter.format_match" href="#dphon.console.MatchHighlighter.format_match">format_match</a></code></li>
<li><code><a title="dphon.console.MatchHighlighter.g2p" href="#dphon.console.MatchHighlighter.g2p">g2p</a></code></li>
<li><code><a title="dphon.console.MatchHighlighter.gap_char" href="#dphon.console.MatchHighlighter.gap_char">gap_char</a></code></li>
<li><code><a title="dphon.console.MatchHighlighter.transcription" href="#dphon.console.MatchHighlighter.transcription">transcription</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>